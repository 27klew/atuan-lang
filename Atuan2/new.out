let id = \x -> x in
  id :: a1 -> a1

let id = \x -> x in
  id id :: a3 -> a3

let id = \x -> let y = x in
                 y in
  id id :: a3 -> a3

let id = \x -> let y = x in
                 y in
  id id 2 :: Int

let id = \x -> x x in
  id
 occurs check fails: a0 vs. a0 -> a1
 in x x

\m -> let y = m in
        let x = y True in
          x :: (Bool -> a1) -> a1

2 2
 types do not unify: Int vs. Int -> a0
 in 2 2

IF  ( True )  then ( 4 )  else ( 5 )  endif :: Int

IF  ( True )  then ( True )  else ( 5 )  endif
 types do not unify: Bool vs. Int

IF  ( 5 )  then ( True )  else ( 5 )  endif
 types do not unify: Int vs. Bool

IF  ( ( True ) || ( True ) )  then ( 4 )  else ( 5 )  endif :: Int

IF  ( ( 4 ) || ( True ) )  then ( True )  else ( 5 )  endif
 types do not unify: Int vs. Bool

IF  ( 5 )  then ( True )  else ( 5 )  endif
 types do not unify: Int vs. Bool

let fun = \x -> IF  ( True )  then ( fun 5 )  else ( 5 )  endif in
  fun 5
 unbound variable: fun
 in fun 5

letrec fun = \x -> IF  ( True )  then ( fun 5 )  else ( 5 )  endif in
  fun 5 :: Int

letrec fun = \x -> IF  ( True )  then ( fun x )  else ( x )  endif in
  fun 5 :: Int

letrec fun = \x -> IF  ( True )  then ( fun x )  else ( x )  endif in
  fun :: a3 -> a3

letrec fun = \x -> IF  ( True )  then ( fun True )  else ( x )  endif in
  fun 5 :: Int

letrec double = \f -> \x -> f (f x) in
  double :: (a6 -> a5) -> a6 -> a5

letrec iter = \f -> \x -> \n -> IF  ( n )  then ( f x )  else ( iter f n )  endif in
  iter :: (a7 -> a8) -> a7 -> Bool -> a8

